import prisma from '@/lib/prisma' // Import the shared instance
import { NextResponse } from 'next/server'
import { z } from 'zod'; // Import Zod
import { getServerSession } from "next-auth/next" // Import getServerSession
import { authOptions } from "@/lib/auth" // Corrected import path

// const prisma = new PrismaClient() // Remove local instantiation

// Define the Zod schema for creating a Hero Component
const HeroCreateSchema = z.object({
  pageId: z.string().cuid({ message: "Invalid Page ID format." }), // Expecting a CUID
  order: z.number().int().min(0, { message: "Order must be a non-negative integer." }),
  headline: z.string().optional(), // Optional string
  subheadline: z.string().optional(),
  summary: z.string().optional(),
  ctaLabel: z.string().optional(),
  ctaLink: z.string().url().optional().or(z.literal('')), // Allow URL or empty string
  resumeLinkLabel: z.string().optional(),
  imageUrl: z.string().url({ message: "Invalid image URL." }).optional().or(z.literal('')), // Allow URL or empty string
  // Note: We don't include fields generated by the DB like id, createdAt, updatedAt
});

// Replace with actual Admin User ID (from DB/config)
const ADMIN_USER_ID = "admin-user-seed-id";

// GET /api/hero - Fetch all Hero components (for now)
export async function GET(request: Request) {
  try {
    const heroComponents = await prisma.heroComponent.findMany({
      orderBy: {
        order: 'asc', // Default ordering
      },
    });
    return NextResponse.json(heroComponents);
  } catch (error) {
    console.error("Error fetching hero components:", error);
    return NextResponse.json(
      { error: "Failed to fetch hero components" },
      { status: 500 }
    );
  }
}

// POST /api/hero - Protected: Create a new Hero component
export async function POST(request: Request) {
  // 1. Check for user session
  const session = await getServerSession(authOptions);
  if (!session?.user) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }

  // Authorization Check using role
  // @ts-ignore
  if (session.user.role !== 'ADMIN') {
    return NextResponse.json({ error: "Forbidden" }, { status: 403 });
  }

  let requestBody;
  try {
    requestBody = await request.json();
  } catch (error) {
    return NextResponse.json({ error: "Invalid JSON body" }, { status: 400 });
  }

  // 2. Validate the request body using Zod
  const validationResult = HeroCreateSchema.safeParse(requestBody);
  if (!validationResult.success) {
    return NextResponse.json(
      {
        error: "Invalid input data",
        details: validationResult.error.flatten().fieldErrors
      },
      { status: 400 }
    );
  }

  const validatedData = validationResult.data;

  // 3. Check if the referenced pageId exists
  try {
    const pageExists = await prisma.page.findUnique({
      where: { id: validatedData.pageId },
      select: { id: true } // Only select the ID, we just need to know if it exists
    });

    if (!pageExists) {
      return NextResponse.json({ error: `Page with ID ${validatedData.pageId} not found.` }, { status: 404 }); // Use 404 Not Found
    }
  } catch (error) {
    console.error("Error checking page existence:", error);
    return NextResponse.json({ error: "Failed to verify page existence" }, { status: 500 });
  }

  // TODO: Further Authorization check: Does user own/have rights to modify this pageId?

  try {
    // 4. Create the component
    const newHeroComponent = await prisma.heroComponent.create({
      data: { ...validatedData },
    });
    return NextResponse.json(newHeroComponent, { status: 201 });
  } catch (error: any) {
    console.error("Error creating hero component:", error);
    // Handle potential Prisma errors (e.g., foreign key constraint)
    if (error.code === 'P2002' && error.meta?.target?.includes('pageId')) {
      // Example: Handling potential unique constraint if added later
      return NextResponse.json({ error: "Component already exists for this page order (if unique constraint added)" }, { status: 409 });
    }
    if (error.code === 'P2003' && error.meta?.field_name?.includes('pageId')) {
      return NextResponse.json({ error: `Page with ID ${validatedData.pageId} does not exist.` }, { status: 400 });
    }

    return NextResponse.json(
      { error: "Failed to create hero component" },
      { status: 500 }
    );
  }
}

// Remove the previous review block for this file as it's superseded
// // --- REVIEW BLOCK START ---
// // Requesting review for the initial HeroComponent API route (GET, POST).
// // Focus areas: Prisma Client usage, route handlers (GET/POST logic), basic validation, error handling, security considerations (TODOs marked).
// // Reviewers: SDE-III (Backend), Principal Architect, Security SME, QA Engineer
// // --- REVIEW BLOCK END --- 

// // --- REVIEW BLOCK START ---
// // Requesting review for the updated POST handler with Zod validation.
// // Focus areas: Zod schema definition, validation logic (safeParse), error response formatting, handling of validated data, basic Prisma error handling.
// // Reviewers: SDE-III (Backend), Principal Architect, Security SME, QA Engineer
// // --- REVIEW BLOCK END --- 

// // --- REVIEW BLOCK START ---
// // Requesting review for the protected POST handler in the hero API route.
// // Focus areas: Use of getServerSession, checking for session existence, placement of the auth check, optional role check comment.
// // Reviewers: SDE-III (Backend), Principal Architect, Security SME, QA Engineer
// // --- REVIEW BLOCK END --- 